## 题解

在分析下载的exe文件时，发现该文件非常小巧，用IDA打开后可以很清楚地看到其结构。文件中没有找到明显的字符串，推测是进行了加密处理。在调试和跟踪过程中，发现主程序逻辑位于 `sub_140001630` 函数中，并成功找到了一个解密函数 `DecryStr_1400013B0`。

读入的密钥在前期没有进行任何处理，只是在其前后分别拼接了两个字符串：

- `3201382652D139C0E22132DF1BC2212EA0991650A229B36436823D0B13D51E6`
- `677116575313142309154604431859253431473963507533496829080645035455771774602058076430276921790210013736267644383505517280`

形成了一个很长的字符串。起初认为这是一个大整数，但因为第二个字符串只包含数字0-9，这一假设不太一致。最终，在字符串前加了一个标记位 `kctf`。

程序后续的函数调用直接使用了系统调用号，这种方式与系统紧密挂钩。但在我的Win7虚拟机中，`NtAllocateVirtualMemory_140002BBA` 调用一直失败，只好手动实现了对应的操作，浪费了不少时间。

由于后续操作一直不成功，只能采用静态分析的方法。发现程序申请了长度为5500的内存空间，把以 `kctf` 开头的字符串写到起始位置，把 `unk_140008050` 开始的2347个字节的代码写入偏移为500的地方，然后通过 `NtQueueApcThread_140002E4E` 启动线程执行该代码，并通过比较返回值是否为“110”还是“120”来判断是否成功。

因此，dump出了该代码段，重新构造了一个exe来执行这段代码。发现该shellcode将代码中的所有 `0x17` 替换为 `0x00`，实现了一个数独矩阵的检测功能。检测数独是否成立的逻辑位于 `sub_140001AA3` 函数中。

```c
char __fastcall sub_140001AA3(__int64 a1)
{
  unsigned int v2; // ebx
  int v3; // ebx
  int v4; // edi
 
  v2 = 0;
  while ( (unsigned __int8)sub_14000193B(a1, v2) && (unsigned __int8)sub_1400019A7(a1, v2) )// 确保行和列不重复
  {
    if ( (int)++v2 >= 9 )
    {
      v3 = 0;
LABEL_6:
      v4 = 0;
      while ( (unsigned __int8)sub_140001A13(a1, (unsigned int)v3, (unsigned int)v4) )
      {
        v4 += 3;
        if ( v4 >= 9 )
        {
          v3 += 3;
          if ( v3 < 9 )
            goto LABEL_6;
          return 1;
        }
      }
      return 0;
    }
  }
  return 0;
}
```

sub_14000193B检测每行，sub_1400019A7检测每列，sub_140001A13检测9个3*3的方阵。

```c
if ( (unsigned __int8)(v19 - '0') > 9u )
{
  if ( (unsigned __int8)(v19 - 'A') > 0x19u )
  {
    if ( (unsigned __int8)(v19 - 'a') > 0x19u )
      break;
    v18 = v19 - 87;
    v17 = 0;
  }
  else
  {
    v18 = v19 - 55;
  }
}
else
{
  v18 = v19 - '0';
}
```

根据程序逻辑，Key前面的字符串是已经放置的21个数字，后面的字符串指示了剩下60个数字的填写顺序。解出已经填写的矩阵如下。

------------------------------
  0  1  2   3  4  5   6  7  8
0 8            
1     3  6       
2   7      9    2
3   5        7                 
4          4 5  7
5        1        3
6     1           6 8 
7     8  5        1
8   9          4

很容易就可以搜索出相应的答案。注意到前后下标的转换关系，按照前面字符串的书写规则得到flag为：`11230A2CD3C31CA32E0D707D38E0743531F80F726C1D133B3A914E2F034B1D63BB17F34428E2A31B038C25E0FA2BF2301053752062AA16E20A2FC1971730E90823D01A724B0CA19B0652811541480B80943AE27E13122C30C120`。
按照规则构造的一个多解为：`11230A2CD3C31CA32ED7a07D38E0743531F80F726C1D133B3A914E2F034B1D63BB17F34428E2A31B038C25E0FA2BF2301053752062AA16E20A2FC1971730E90823D01A724B0CA19B0652811541480B80943AE27E13122C30C120`。