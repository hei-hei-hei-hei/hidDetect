# math

```python
from Crypto.Util.number import *
from secret import prng
import os
flag = os.environ.get('FLAG', 'HCTF{this_is_a_sample_flag}')
 
#prng 参考2023新课标I卷P20
sys = prng()
 
 
def constraint():
    time = 1000
    sample_a = []
    sample_b = []
    for _ in range(time):
        out =  sys.next()
        sample_a.append(out[0])
        sample_b.append(out[1])
    assert all([sample_a[i]-sample_a[i-1] == sys.d for i in range(1, time)])
    assert all([sample_b[i-1] == (i**2+i)/sample_a[i-1] for i in range(1, time)])
    assert 3*sample_a[1] == 3*sample_a[0]+sample_a[2]
    return sum(sample_a[:777]+sample_b[:777])
 
 
def rsa_plus(m):
    p = getPrime(512)
    q = getPrime(512)
    n = p*q
    e = 0x10001
    m = bytes_to_long(m.encode())
    r1 = sys.next()[0]
    r2 = sys.next()[0]
    c = pow(pow(pow(m, e, n)*r1, e, n)*r2, e, n)
    h = 2*p+3*q
    return n, c, h
 
h1 = constraint()
n, c, h2 = rsa_plus(flag)
print(f'n = {n}')
print(f'c = {c}')
print(f'hint1 = {h1}')
print(f'hint2 = {h2}')
"""
n = 123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527
c = 70355784775921655880380025465489949573241301926464797611681833071256665441460869302372712558837199110767728290007652944220079907048322612573185968943864339915304868935319658344195708544022979094906385190425552202576200107202487083736800245172584184112275476974513051986233708501062909943346214681580048469716
hint1 = 234850971.0
hint2 = 54673117809069678475594947601860826118221736045735845051744912971409541561632603188516528135267179886112707141940065852170163389165168708306257365103150093
"""
```

`constraint()`函数描述了2023新课标卷P20的题干部分
并且告诉我们 $h1$ 是 $a_n$ 和 $b_n$ 的前777项和，即

$S_{777} + T_{777} = h1$

我们由此可以计算出 $a_n$ 的通项公式为 $a_n = 777n$
根据 $time=1000$，我们可以得出 $r_1$ 和 $r_2$ 是数列 an 的第1001项和第1002项，即：

$r1 = 777 * 1001\ r2 = 777 * 1002$

然后根据含有p, q的两个式子，可以得到一个二元方程组：

$\left\{\begin{array}{l}
p * q=n \\
2 * p+3 * q=\text { hint } 2
\end{array}\right.$

其中n和hint2都是已知的，因此我们可以解出p和q。

```python
from sympy import symbols, Eq, solve
import gmpy2
# 定义未知数
p, q = symbols("p q")
# 解方程
expr2 = [2*p+3*q-54673117809069678475594947601860826118221736045735845051744912971409541561632603188516528135267179886112707141940065852170163389165168708306257365103150093, p*q-123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527]
r2 = solve(expr2, [p, q])
print("r2:", r2)
```

得到：

```text
p = 12384051763953430863668172341605062087552196009776396484360059546294965143403046818805051855772540020996782547927228938821561716941140613694437078638123523
q = 9968338093720938916086200972883567314372448008727684027674931292939870424942169850302141474574033281373047348695202658175679985094295826972461069275634349
```

然后我们根据`c = pow(pow(pow(m, e, n)*r1, e, n)*r2, e, n)`
进行解密

```python
import gmpy2
from Crypto.Util.number import *
r1=1001*777
r2=1002*777
p = 12384051763953430863668172341605062087552196009776396484360059546294965143403046818805051855772540020996782547927228938821561716941140613694437078638123523
q = 9968338093720938916086200972883567314372448008727684027674931292939870424942169850302141474574033281373047348695202658175679985094295826972461069275634349
c = 70355784775921655880380025465489949573241301926464797611681833071256665441460869302372712558837199110767728290007652944220079907048322612573185968943864339915304868935319658344195708544022979094906385190425552202576200107202487083736800245172584184112275476974513051986233708501062909943346214681580048469716
e = 0x10001
n = 123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
c1 = m*gmpy2.invert(r2, n)
m1 = pow(c1, d, n)
c2 = m1*gmpy2.invert(r1, n)
m2 = pow(c2, d, n)
print(long_to_bytes(m2).decode())
```

在共模下做除法法我们需要求出r1和r2关于n的逆元$ r_1^{-1} $ 和$ r_2^{-1} $

最终解得flag为：`HCTF{D0_y0u_900d_4t_m47h?###}`
